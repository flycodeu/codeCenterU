# 溢出专题
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://www.flycode.icu)

[整数反转](https://leetcode.cn/problems/reverse-integer/)

[回文数](https://leetcode.cn/problems/palindrome-number/)



## 整数反转

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

**示例 3：**

```
输入：x = 120
输出：21
```

**示例 4：**

```
输入：x = 0
输出：0
```





### 数学

以123为例

```
123%10 = 3              
123%10%10 = 2
123%10%10%10 = 1
```

我们通过取余就可以获取到每一轮的末尾数字，然后再通过 num*10的方式来计算新的反转数字，步骤如下

```
while(x!=0){
	res = res*10+ x%10;
	x = x/10;
}
```

但是题目中会出现溢出的情况，比如式Integer的最大值末尾是7，所以反转后肯定溢出了，我们需要单独判断是否溢出。

```java
    public int reverse(int x) {
        int num = 0;
        while(x!=0){
            if(num>Integer.MAX_VALUE/10 || num<Integer.MIN_VALUE/10){
                return 0;
            }

            int temp = x%10;
            x /= 10;
            num = num*10+temp;
        }
        return num;
    }
```



## 回文数

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

**示例 3：**

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```



最简单的做法就是采用一个新的元素来逆序存储x对应的位数的值，然后判断两个值是否相等。

```java
 public boolean isPalindrome(int x) {
        if(x<0){
            return false;
        }
        int num = 0;
        int n = x;
        while(n!=0){
            num = num*10+n%10;
            n=n/10;
        }
        return num==x;
    }
```



虽然以上方式能够正常通过检测，但是存在一些问题

- 如果这个x和第一题一样，出现了溢出怎么办？
- 是否有必要完全反转数字？

我们没有必要将数字完全反转，只需要反转一半，然后比较，这样也就能避免溢出和完全反转数字的问题，我们也没必要去使用一个变量来保存x的值。

```java
    public boolean isPalindrome(int x) {
        // 防止最后一个是0，但是首位不是0
        if(x<0 || (x%10 == 0 && x!=0)){
            return false;
        }
        int num = 0;
        while(x>num){
            num = num*10+x%10;
            x=x/10;
        }

        // 当数字长度为奇数时,我们可以通过 num/10 去除处于中位的数字。
        //例如,当输入为12321时,在while 循环的末尾我们可以得到 x=12,num = 123
        // 由于处于中位的数字不影响回文(它总是与自己相等),所以我们可以简单地将其去除。
        return num==x || num/10==x;
    }
```

