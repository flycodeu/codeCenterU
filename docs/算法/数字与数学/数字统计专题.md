# 数字统计专题
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://www.flycode.icu)

[数组元素积的符号](https://leetcode.cn/problems/sign-of-the-product-of-an-array/)

[面试题 16.05. 阶乘尾数](https://leetcode.cn/problems/factorial-zeros-lcci/)

## 数组元素积的符号

已知函数 `signFunc(x)` 将会根据 `x` 的正负返回特定值：

- 如果 `x` 是正数，返回 `1` 。
- 如果 `x` 是负数，返回 `-1` 。
- 如果 `x` 是等于 `0` ，返回 `0` 。

给你一个整数数组 `nums` 。令 `product` 为数组 `nums` 中所有元素值的乘积。

返回 `signFunc(product)` 。



> **示例 1：**
>
> ```
> 输入：nums = [-1,-2,-3,-4,3,2,1]
> 输出：1
> 解释：数组中所有值的乘积是 144 ，且 signFunc(144) = 1
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,5,0,2,-3]
> 输出：0
> 解释：数组中所有值的乘积是 0 ，且 signFunc(0) = 0
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [-1,1,-1,1,-1]
> 输出：-1
> 解释：数组中所有值的乘积是 -1 ，且 signFunc(-1) = -1
> ```



### 遍历

遍历的时候我们只需要判断0和负数，如果里面有0，那么最终乘积就是0，而正数相乘肯定还是正数，所以我们只需要考虑负数的情况。

我们并不需要关心最终的结果是什么，我们只需要关注正负号，所以我们只需要看有多少个负数就可以。

```java
    public int arraySign(int[] nums) {
        int res = 1;
        for(int i=0;i<nums.length;i++){
            if(nums[i] == 0){
                return 0;
            }else if(nums[i] <0){
                res = -res;
            }
        }
        return res;
    }
```



## 面试题 16.05. 阶乘尾数

设计一个算法，算出 n 阶乘有多少个尾随零。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 





### 遍历

要出现0，只有2和5的组合才能有0，但是2在5的前面，出现了5一定会出现2，所以我们只需要考虑5或者5的倍数出现的情况

```java
    public int trailingZeroes(int n) {
        // 只有2和5存在里面，才会出现尾数为0的情况,但是2一定出现在5的前面，只需要考虑5出现次数就行
        int res = 0;
        while(n!=0){
            n/=5;
            res+=n;
        }
        return res;
    }
```

