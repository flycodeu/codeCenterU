# 基本的二分查找
> 本文作者：程序员飞云
>
> 本站地址：[https://flycode.icu](https://flycode.icu)



## 二分查找--循环

代码没什么好说的，但是有几个细节需要注意

外部定义左右位置

```java
    public static int binarySearch(int[] arr, int left, int right, int target) {
        while (left <= right) {
            // 避免溢出
            int mid = left + ((right - left) >> 1);
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
```

内部定义左右位置

```java
public static int binarySearchInner(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        // 避免溢出
        int mid = left + ((right - left) >> 1);
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

问题：

1. 为什么是left<=right？
2. 为什么是mid+1和mid-1赋值给left和right？



问题1：

此处定义的区间是`[left,right]`，而`[left,left]`是符合区间的定义的，最终的结果就是left

问题2：

`left=mid+1`因为`arr[mid]`此时已经不符合小于`target`，所以必须要+1

`right=mid-1`因为`arr[mid]`此时已经大于`target`，我们不能再使用mid计算，而是使用mid+1



在实际操作过程中区间并不一定是[left,right],而是[left,right)

因为right取不到，所以left不能等于right，如果等了就变成了`[left,left)`

同理当arr[mid]>target的时候，right=mid,因为此处的mid取不到，所以可以等于

```java
    public static int binarySearch2(int[] arr, int target) {
        int left = 0;
        int right = arr.length;
        while (left < right) {
            // 避免溢出
            int mid = left + ((right - left) >> 1);
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid ;
            }
        }
        return -1;
    }
```



