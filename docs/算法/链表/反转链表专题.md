# 反转链表专题
> 本文作者：程序员飞云
>
> 本站地址：[https://flycode.icu](https://flycode.icu)

涉及题目

[反转链表Ⅱ](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

[单链表加1](https://leetcode.cn/problems/plus-one-linked-list/description/)(需要会员)

[两数相加](https://leetcode.cn/problems/add-two-numbers-ii/description/)

[回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/)



## 反转链表 Ⅱ

这一题快手笔试的时候出过。

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

![image-20240120101220115](http://cdn.flycode.icu/codeCenterImg/202401201012204.png)

> ```
> 输入：head = [1,2,3,4,5], left = 2, right = 4
> 输出：[1,4,3,2,5]
> ```



### 头插法

主要思路就是将后面的节点插入到第一个节点的前面，如下图所示：

![image-20240120102851487](http://cdn.flycode.icu/codeCenterImg/202401201028555.png)

首先我们需要先找到`left`处节点的前一个节点记为`pre`，这样做的主要原因是防止和后续的节点丢失联系，只需要通过`next`指向就能获取`left`处的节点，这个节点记为`cur`。

当我们获取到了`left`处的节点`cur`后，需要记录后一个节点记为`next`，这个节点是一直会随着`cur`的下一个节点的改变而改变的，所以需要放在循环里面。

我们以第一步为例：

1. 首先`next`的指针需要改变，先将`cur`和`next`的下一个节点连接起来`cur.next = next.next`
2. 然后需要将现在的`2->3`的箭头关系修改成`3->2`，而这样就需要将`next`指针指向`pre`的下一个节点的位置，也就是`next.next = pre.next`，现在也就完成了这两个节点的反转
3. 但是之前的`pre`和`cur`是有指针关系的，现在`next`到了`cur`的前面，需要重新连接对应的关系，`pre.next = next`

图示如下：

![image-20240120104602304](http://cdn.flycode.icu/codeCenterImg/202401201046385.png)

之后的步骤也是同理，这个里面也就是将4插入到3的前面



```java
    public ListNode reverseBetween(ListNode head, int left, int right) {
       ListNode dummyHead = new ListNode(-1,head);
       ListNode pre = dummyHead;
       // 找到left处前一个节点的位置
       for(int i=1;i<left;i++){
           pre = pre.next;
       }
       ListNode cur = pre.next;
       // 记录下一个next的节点
       ListNode next ;
       
       for(int j=0;j<right-left;j++){
           next = cur.next;
           cur.next = next.next;
           next.next = pre.next;
           pre.next = next;
       }
       return dummyHead.next;
    }

```

时间复杂度：O（N）只需要遍历一次链表就可以完成反转

空间复杂度：O（1）



这种方法相对于下面的方法还有一个好处就是万一链表里面的left和right位置就是整个链表的长度区间，也是一样的处理，不需要额外的其他操作。



### 穿针引线法

其实这个链表可以看作三个部分，第一个部分是`left`左侧，第二个部分是`left -- right`，第三个部分是`right`的右侧，中间的反转操作就可以采取我们之前学习的链表反转，然后将反转的链表重新和原来的链表进行拼接。但是接下来的难点在于如何拼接这个新的链表。

![image-20240120110357993](http://cdn.flycode.icu/codeCenterImg/202401201103056.png)

```java
    public ListNode reverseBetween(ListNode head, int left, int right) {
       // 1. 定义虚拟节点
       ListNode dummyHead = new ListNode(-1,head);
       ListNode prev = dummyHead;
       // 2. 找到left的前一个节点的位置
       for(int i=1;i<left;i++){
           prev = prev.next;
       }
        // 3. 找到left的节点位置
       ListNode leftNode = prev.next;
       // 4. 找到right节点位置
       ListNode rightNode = prev;
       for(int j=0;j<right-left+1;j++){
           rightNode = rightNode.next;
       }
       // 5. 找到right下一个节点
       ListNode nextNode = rightNode.next;
       // 6.断开链表联系
        prev.next = null;
        rightNode.next = null;
       // 7. 反转链表
       reverseListNode(leftNode);
       // 8. 拼接链表
       prev.next = rightNode;
       leftNode.next = nextNode;

       return dummyHead.next;
    }

	/**
	* 反转链表
	*/
    public void reverseListNode(ListNode head){
        ListNode prev = null;
        ListNode cur = head;
        while(cur!=null){
            ListNode next = cur.next;
            cur.next = prev;
            prev=cur;
            cur = next;
        }
    }
```

时间复杂度：O（N）

空间复杂度：O（1）

但是这个方法存在一点问题，要是left和right的区间就是整个链表，第一次寻找右节点的时候需要遍历一次整个链表，第二次反转链表是需要反转整个链表，又需要遍历一次，相当于遍历了两次这个链表。



## 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

> ![image-20240120113854154](http://cdn.flycode.icu/codeCenterImg/202401201138206.png)
>
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```



这一题我们首先需要画出完整的交换流程。

![image-20240120115353828](http://cdn.flycode.icu/codeCenterImg/202401201153903.png)

主要变换步骤

1. `cur.next == node2`，cur是第一个节点
2. `node1.next==node3`
3. `node2.next == node1`
4. 此时的`cur`需要移动到`node1`的位置，也就是`cur=node1`

里面的第二步和第三步不能反转，因为如果反了，那么进行`node2.next == node1`，此时`node1`已经无法获取之前的`node2`的下一个节点的位置

我们这边需要使用三个节点，`node1，node2，node3`，遍历的时候除了判断`node1`是否为空还要判断`node2`是否为空。

```java
   public ListNode swapPairs(ListNode head) {
        ListNode dummHead = new ListNode(-1,head);
        ListNode cur = dummHead;
        while(cur.next!=null && cur.next.next!=null){
            ListNode node1 = cur.next;
            ListNode node2 = cur.next.next;
            cur.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            cur = node1;
        }
        return dummHead.next;
    }
```

时间复杂度：O（N）

空间复杂度：O（1）

###



