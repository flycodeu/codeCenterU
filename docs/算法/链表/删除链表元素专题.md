# 删除链表元素专题

这一专题包含4个主要内容

- 删除特定节点
- 删除倒数第n个节点
- 删除重复元素，重复元素保留一个
- 删除重复元素，重复元素都删除

涉及题目
[移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)
[删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)
[删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
[删除链表M个节点之后的N个节点](https://leetcode.cn/problems/delete-n-nodes-after-m-nodes-of-a-linked-list)
[删除排序链表种重复的元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)
[删除排序链表中的重复元素 2](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)

## 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点。

> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```

![image-20240113152220098](http://cdn.flycode.icu/codeCenterImg/202401131522218.png)

首先，这道题目最先想到的就是依次遍历，找到对应的节点之后，将这个节点舍弃掉，与下一个节点建立联系，从而形成一个新的链表。

![image-20240113152825374](http://cdn.flycode.icu/codeCenterImg/202401131528424.png)

![image-20240113155925319](http://cdn.flycode.icu/codeCenterImg/202401131559370.png)

我们先以上图为例，定义一个cur指针一直移动，还需要定义一个指针记录当前cur的前一个节点pre，只有当cur遇到目标值的时候，这时候需要将前一个节点的下一个指针指向cur的下一个节点，这样才完成了一次拼接，此时cur就需要移动新的节点，也就是`pre.next = cur.next`，这就是迭代的思想。

但是只有上面的分析，并不够，如果现在出现了第一个节点的值就是目标值，此时它的前面没有节点，所以pre指针也就无效了。核心难点在于我们无法记录头节点，导致无法进行下一步。

这里有两种方案

- 第一种是单独判断头节点，如果头节点是目标值，那就采取头删除法，设置下一个节点为头节点。
- 第二种是使用一个虚拟节点来作为头节点，而这个虚拟节点当程序运行结束后，只需要返回后续的节点，就能达到我们的需求，这样就不会丢失头节点的记录，而且还不需要额外的判断，如下图所示

![image-20240113160100606](http://cdn.flycode.icu/codeCenterImg/202401131601650.png)

代码如下：

### 迭代法

```java
 public ListNode removeElements(ListNode head, int val) {        
        if(head == null){
            return head;
        }
        // 虚拟节点
        ListNode dummyHead = new ListNode(-1,head);
     	// 获取目标节点
        ListNode cur = head;
     	// 目标节点的前一个节点
        ListNode pre = dummyHead;
        while(cur!=null){
            if(cur.val == val){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return dummyHead.next;
    }
```

时间复杂度: O(n)，n是链表的长度，需要遍历一次链表

空间复杂度: O(1)

### 递归法

大部分的链表都能使用递归来做，链表结束的条件是到达null，方法`removeElements`返回的`ListNode`是新一轮的节点，而条件就是判断当前head的val和预期是否相同，如果相同就跳过这个节点，去找下一个节点，一直到null。

```java
public ListNode removeElements(ListNode head, int val) {        
        if(head == null){
            return head;
        }
        head.next = removeElements(head.next,val);
        return head.val == val ? head.next: head;
    }
```

时间复杂度：O（n），n是链表的长度，遍历了一次链表的长度

空间复杂度：O（n），空间复杂度取决于递归调用栈，最多就n层。

怎么说呢，递归的这个方法一看就懂，一写就废。



## 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

![image-20240113162123944](http://cdn.flycode.icu/codeCenterImg/202401131621999.png)

> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```

第一个反应是将链表反转过来，变成正向的链表位置，删除对应的节点后，再反转过来，的确是可以做的，但是这边反转了两次链表，还需要编写一个反转的方法，整体上还是比较麻烦的。

### 计算链表长度

首先题目求的是倒数的节点，如果题目变成了正向的节点，那么就可以操作了，那么如何变成正向的。以上示例要删除的是倒数第2个节点，其对应的值是4，那么4在正向的第4个节点，而总长度是5，而5-2+1就可以得到对应的正向的节点位置，总结正向的位置就变成了 L-n+1。这样就好做多了。

依然还是需要一个虚拟节点来记录头节点

```java
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 虚拟节点
        ListNode dummyHead = new ListNode(-1,head);
        // 计算链表长度
        int length = getNodeLength(head);
        // 正向位置
        int targetIndex = length - n+1;
       
        ListNode cur  = dummyHead;
        for(int i =1;i<targetIndex;i++){
            cur = cur.next;
        }
        // 移动到新的节点
        cur.next = cur.next.next;
        return dummyHead.next;
    }
    /**
    * 计算长度
    * count 从1开始
     */
    public int getNodeLength(ListNode head){
        int count = 1;
        ListNode temp = head;
        while(temp.next!=null){
            count++;
            temp=temp.next;
        }
        return count;
    }
```

以上代码有一个我经常出错的地方，就是计算长度的时候，循环条件的问题，一旦count设置为0，那么里面的条件是`temp!=null`，但是如果count是从1开始，里面就是`temp.next!=null`。

时间复杂度：O（L），L是链表的长度

空间复杂度：O（1）

### 双指针

![image-20240113162123944](http://cdn.flycode.icu/codeCenterImg/202401131621999.png)

我们可以设置两个指针，只需要第一个指针走了N步后，第二个指针才开始走，当第一个指针走到null的时候，第二个指针就到了指定的位置，其实变相的正向，快指针走结束了，那么链表长度就计算出来了，慢指针和快指针中间隔了n步，然后慢指针停留的地方就是倒数n的位置。

![image-20240113174635162](http://cdn.flycode.icu/codeCenterImg/202401131746227.png)

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
      // 虚拟节点
      ListNode dummyHead = new ListNode(-1,head);
     // 快指针
      ListNode fast = head;
     // 慢指针
      ListNode slow = dummyHead;
     // 快指针先走
      for(int i=1;i<=n;i++){
          fast = fast.next;
      }
     // 两个指针同时走，直到快指针走到null
      while(fast!=null){
          fast =fast.next;
          slow = slow.next;
      }
	 // 找到倒数n的位置的前一个节点，进行交换
      slow.next = slow.next.next;
      return dummyHead.next;
    }
```

以上代码需要注意的是慢指针的位置，这边设置在虚拟节点为初始位置，就是要找到目标节点的前一个节点的位置。

时间复杂度: O（L），遍历了一次链表的长度

空间复杂度: O(1)

