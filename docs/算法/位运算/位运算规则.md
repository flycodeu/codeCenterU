# 位运算规则
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://www.flycode.icu)



## 与、或、异或、取反

### 与 (&)

每个二进制位，当两个对应的数字位都是1的时候，结果才为1，否则为0

```
0 & 0 = 0
0 & 1 = 0
1 & 1 = 1
1 & 0 = 0
```

### 或(|)

每个二进制位，当两个对应的数字位有一个是1，结果才为1，否则都是0

```
0 | 1 = 1
0 | 0 = 0
1 | 0 = 1
1 | 1 = 1
```

### 异或 (⊕)

每个二进制位，两个数对应的位相同，结果为0

（代码里面采用^）

```
0 ⊕ 0 = 0
0 ⊕ 1 = 1
1 ⊕ 0 = 1
1 ⊕ 1 = 0
```

### 取反(~)

对应的0变成1，1变成0

```
~0 = 1
~1 = 0 
```



### 案例

46的二进制表示是00101110,51的二进制表示是00110011。考虑以下位运算的结果。

- 46&51的结果是34,对应的二进制表示是00100010。
- 46|51 的结果是63,对应的二进制表示是00111111。
- 46⊕51 的结果是29,对应的二进制表示是00011101。
- ~ 46的结果是-47,对应的二进制表示是11010001。
- ~ 51的结果是-52,对应的二进制表示是11001100。



## 移位运算

移位运算分为左移和右移，按照符号划分可以分为算数移位和逻辑移位。

左移运算符号 <<，将全部的二进制位向左移动若干位，高位丢弃，低位补0。算术移位和逻辑移位一样。

右移运算符号 >>，将全部二进制位向右移动若干位,低位丢弃,高位的补位由算术移位或逻辑移位决定:

- 算术右移时,高位补最高位;
- 逻辑右移时,高位补0。



### 案例

1. 29左移

29的8位二进制是   00011101

左移两位： 01110100  =  116

左移三位： 11101000，而最高位的1表示负数，这是一个补码，我们需要转化成对应的原码才能知道对应的结果

11101000 - 1  =  11100111 取反 00011000，整数值是 24，最后的结果是 - 24



2. 50右移

50的二进制是： 00110010

50右移1位： 00011001 = 25

50右移2位： 00001100 = 12

正数的算术右移和逻辑右移都是一致的。



3. -50右移

-50 二进制补码表示   （00110010）取反 11001101 - 1 = 11001100（补码）

-50 算术右移1位：11100110    11100110取反  = 00011001 +1 = 00011010（整数）=26， 值是-26

-50 算术右移2位：11110011    11110011取反=00001100+1=00001101=13，值是-13

-50 逻辑右移2位（高位补0）：00110011  值是51



## 移位和乘除关系

左移对应的乘法计算，当前数乘以 2^k

算术右移对应的是除法计算，相当于当前的数除以2^k



## 位运算常用技巧

- 幂等律:`a&a=a`, `a |a=a`(注意异或不满足幂等律);
- 交换律:`a&b=b &a`, `a| b=b| a`,`a⊕b=b⊕a`;
- 结合律:`(a&b)& c=a&(b&c)`,`(a|b) | c=a|(b|c)`,`(a⊕b)⊕c=a⊕(b⊕c)`;
- 分配律:`(a&b)|c=(a|c)&(b|c)`,`(a | b)& c=(a&c)|(b&c)`,`(a⊕b)&c=(a& c)⊕(b&
  c)`;
- 德摩根律 :`~ (a&b)=(~a)|(~b)`,`~(a| b)=(~a)& (~b)`;
- 取反运算性质 :-` 1 =~ 0`,`-a =~ (a-1)`;
- 与运算性质:`a&0=0`,`a&(-1)=a`, `a&(~a)=0`;
- 或运算性质:`a|0=a`;
- 异或运算性质:`a⊕0=a`,`a⊕a=0`;

根据以上的性质可以推算出一些应用技巧

- `a&(a-1)`将二进制结果的最后一个1变成0
- `a&(-a)`只保留二进制最后一个1，其余的1都变成0

![image-20240217105356474](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240217105356474.png)

如何获取，设置，更新某个位的数据？

1. 获取

该方法是将1左移i位,得到形如00010000的值。接着堆这个值与num执行”位与“操作,从而将i位之外的所有位清零,最后检查该结果是否为零。不为零说明i位为1,否则i位为0。代码如下:

```java
    boolean getBit(int num,int i){
        return ((num&(1<<i))!=0);
    }
```

设置(将某一位设置成1)

`setBit`先将1左移i位,得到形如00010000的值,接着堆这个值和`num`执行”位或“操作,这样只会改变位的数据。这样除i位外的位均为零,故不会影响`num`的其余位。代码如下:

```java
int setBit(int num,int i){
    return num|(1<<i);
}
```

清0（某一位设置为0）

该方法与`setBit`相反,首先将1左移i位获得形如00010000的值,对这个值取反进而得到类似11101111的值,接着对该值和`num`执行”位与“,故而不会影响到`num`的其余位,只会清零i位。

```java
int clearBit(int num,int i){
    int mask = ~(1<<i);
    return mask;
}
```

更新

这个方法是将`setBit`和`clearBit`合二为一,首先用诸如11101111的值将`num`的第i位清零。接着将待写入值v左移i位,得到一个i位为v但其余位都为0的数。最后对之前的结果执行”位或“操作,v为1这`num`的i位更新为1,否则为0:

```java
int updateBit(int num, int i, int v) {
    int mask = ~(1 << i);
    return (num & mask | (v << i));
}
```
