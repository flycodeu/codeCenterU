# 位移的使用
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://www.flycode.icu)

[位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

[比特位计数](https://leetcode.cn/problems/counting-bits/)

[颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)



## 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

 ```
 示例 1：
 输入：n = 00000000000000000000000000001011
 输出：3
 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 示例 2：
 
 输入：n = 00000000000000000000000010000000
 输出：1
 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 示例 3：
 
 输入：n = 11111111111111111111111111111101
 输出：31
 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 ```



### 循环检查二进制是否为1

我们以`00000000000000000000000000001011`为例，使用这个`n&1`能够计算出最后一个是否为1，`n&11`能够计算出最后两个是否为1，以此类推，但是我们这样无法计算1出现的次数，我们是否可以移动n来进行比较，因为n的长度是32位，每次右移一位，都可以将对应的位置二进制数和1进行比较，然后计数。

```java
  public int hammingWeight(int n) {
        int count = 0;
        for(int i=0;i<32;i++){
            count +=(n>>i)&1;
        }
        return count;
    }
```



### 优化位运算

利用n&(n-1)将最后一个1变成0

```
n:   	 00000100100100010000110001000100
n-1:     00000100100100010000110001000011
n&(n-1): 00000100100100010000110001000000
```

一直执行n&(n-1)直到值为0

```java
 public int hammingWeight(int n) {
        int count = 0;
        while(n!=0){
            n=n&(n-1);
            count++;
        }
        return count;
    }
```



## 比特位计数

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

 ```
 示例 1：
 
 输入：n = 2
 输出：[0,1,1]
 解释：
 0 --> 0
 1 --> 1
 2 --> 10
 示例 2：
 
 输入：n = 5
 输出：[0,1,1,2,1,2]
 解释：
 0 --> 0
 1 --> 1
 2 --> 10
 3 --> 11
 4 --> 100
 5 --> 101
 ```

### 位运算

题目的本质就是求当前的i里面有多少个1，然后将次数写入到数组里面去，我们依然可以利用n&(n-1)来将最后一个1变成0，然后计算修改成0的次数就可以。

```java
    public int[] countBits(int n) {
        int [] res = new int [n+1];
        for(int i=0;i<=n;i++){
            res[i] = countOnes(i);
        }
        return res;
    }


    public int countOnes(int n){
        int count = 0;
        while(n>0){
            n = n&(n-1);
            count++;
        }
        return count;
    }
```



## 颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

**示例 1：**

```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例 2：**

```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 
```

### 位运算

我们注意到对于 n的二进制表示的从低到高第i位,在颠倒之后变成第31-i位(0≤i<32),所以可以从低到高遍历 n的二进制表示的每一位,将其放到其在颠倒之后的位置,最后相加即可。

```java
    public int reverseBits(int n) {
        // 存储颠倒后的结果
        int reversed = 0;
        // 初始化power当前位的幂
        int power = 31;
        // 有位数还需要颠倒
        while(n!=0){
            // n的最低位放在reversed的位置
            reversed+=(n&1)<<power;
            // n右移
            n >>>= 1;
            power--;
        }
        return reversed;
    }
```

以n = 00000010100101000001111010011100为例

第一次操作

n&1 = 0，reversed=0，n右移，n=00000001010010100000111101001110

第二次操作

n&1 =0  reversed = 00,   n=0000000101001010000011110100111

第三次操作

n&1=1 reversed = 001, n=00000000010100101000001111010011

...直到最后n是0，这样就完成了颠倒







## 总结

位运算的代码看起来都很简单，步骤也都理解，但是真到了自己思考写的时候，就不知道如何下手了。
