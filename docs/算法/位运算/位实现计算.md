# 位实现计算
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://www.flycode.icu)

[两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)

[面试题 08.05. 递归乘法](https://leetcode.cn/problems/recursive-mulitply-lcci/)



## 两整数之和

给你两个整数 `a` 和 `b` ，**不使用** 运算符 `+` 和 `-` ，计算并返回两整数之和。

**示例 1：**

```
输入：a = 1, b = 2
输出：3
```

**示例 2：**

```
输入：a = 2, b = 3
输出：5
```



### 位运算

a=1 b =2  a=01 b =10   a^b = 11

里面没有发生进位，直接采用异或就可以。



 a=2,b=3，对应的二进制是10和11

二进制加法的情况

```lisp
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 0 (进位)
```

![image-20240218101225243](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240218101225243.png)

只有对应的位相同并且为1，才会发生进位，而此时的位上为0，而这个条件满足&运算，但是&运算对于 1+1 = 1，我们是否可以改造成对应的题目情况，我们可以让这个1左移一位，就变成了10，而此位上的值就是0。

进位采用 &和移位来计算

不进位的就采用^来计算。

操作步骤就可以如下：

![image-20240218102300033](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240218102300033.png)



```java
    public int getSum(int a, int b) {
        while(b!=0){
            int sign = (a&b)<<1;
            a = a^b;
            b = sign;
        }
        return a;
    }
```



## 面试题 08.05. 递归乘法

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。

**示例1:**

```
 输入：A = 1, B = 10
 输出：10
```

**示例2:**

```
 输入：A = 3, B = 4
 输出：12
```



### 位运算

我们需要以二进制的视角来看待乘法，比如现在有个例子是 `A=13, B=12`

A是较大的，所以不需要拆开，我们可以来拆分B，将B转换为2进制的形式,拆分为2的幂次方

![image-20240218103955301](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240218103955301.png)

就变成了 13 *(8+4)=13 `*` 8+13`*`4，而这样我们就能采用移位，乘法相当于左移，`13 << 3 + 13 << 2`。

回归到代码上面去，我们只需要判断当前最小值对应的位数是否为1，如果为一就需要进行加法运算，不唯一，那么最小值就需要右移，继续判断当前位。

```java
public int multiply(int A, int B) {
        int min = Math.min(A,B);
        int max = Math.max(A,B);
        int res = 0;
        for(int i=0; min!=0;i++){
            // 当前位为1才计算
            if((min&1)==1){
                res += max<< i;
            }
            min >>= 1;
        }
        return res;
    }
```





## 总结

位的运算看起来简单，但是实际理解起来真的有点绕。关于一些位的操作还需要进一步的思考·学习。
