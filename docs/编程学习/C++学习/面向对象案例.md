# 面向对象案例
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://flycode.icu)



## 项目目标

实现动态可变的数据容器

1. 添加元素（末尾，指定下标）
2. 删除元素（下标，按照元素删除，清空）
3. 修改元素（下标）
4. 获取元素（下标）
5. 元素排序
6. 元素下标查询
7. 容器中的元素拼接为字符串返回



## 项目分析

可变容器：数组版，双链表版本



## 步骤

### 定义接口模板类(QFMutableContainer.h)

```c++
#pragma once

// 定义类模板
template<typename E>
class QFMutableContainer {
public:
	//末尾添加元素
	virtual void add(E ele) = 0;

	// 指定位置添加元素
	virtual void add(int index, E ele) = 0;

	// 删除指定位置元素
	virtual E remove(int index) = 0;

	// 删除指定元素
	virtual bool removeElement(E ele) = 0;

	// 清空元素
	virtual void clear() = 0;

	// 修改指定下标元素
	virtual E set(int index, E ele) = 0;

	// 获取指定下标元素
	virtual E get(int index = 0) = 0;

	// 元素排序
	virtual void sort() = 0;

	// 获取对应元素的下标
	virtual int index(E ele) = 0;

	//容器元素字符串返回
	virtual string str() = 0;
    
    //析构函数
	virtual ~QFMutableContainer() {

	};
};
```



### 定义数组实现

```c++
#pragma once
#include "QFMutableContainer.h"
#include <string>
using namespace std;

// 数组实现
template<typename E>
class QFMutableArray: public QFMutableContainer<E>{
private:
	// 存放元素
	E* array;
	int len;

public:
	//末尾添加元素
	void add(E ele) override;

	// 指定位置添加元素
	void add(int index, E ele) override;

	// 删除指定位置元素
	E remove(int index) override ;

	// 删除指定元素
	bool removeElement(E ele) override;

	// 清空元素
	void clear() override;

	// 修改指定下标元素
	E set(int index, E ele) override;

	// 获取指定下标元素
	E get(int index = 0) override;

	// 元素排序
	void sort() override ;

	// 获取对应元素的下标
	int index(E ele) override;

	//容器元素字符串返回
	string str() override ;


	// 析构函数
	~QFMutableArray() override;
    
    // 构造函数
	QFMutableArray();
};

template<typename E>
inline void QFMutableArray<E>::add(E ele)
{
}

template<typename E>
inline void QFMutableArray<E>::add(int index, E ele)
{
}

template<typename E>
inline E QFMutableArray<E>::remove(int index)
{
	return E();
}

template<typename E>
inline bool QFMutableArray<E>::removeElement(E ele)
{
	return false;
}

template<typename E>
inline void QFMutableArray<E>::clear()
{
}

template<typename E>
inline E QFMutableArray<E>::set(int index, E ele)
{
	return E();
}

template<typename E>
inline E QFMutableArray<E>::get(int index)
{
	return E();
}

template<typename E>
inline void QFMutableArray<E>::sort()
{
}

template<typename E>
inline int QFMutableArray<E>::index(E ele)
{
	return 0;
}

template<typename E>
inline string QFMutableArray<E>::str()
{
	return string();
}

template<typename E>
inline QFMutableArray<E>::~QFMutableArray()
{
	if (array != nullptr) {
		delete array;
		array = nullptr;
	}
}

template<typename E>
inline QFMutableArray<E>::QFMutableArray()
{
	array = new E[0];
	len = 0;
}

```

### 实现字符串返回

```c++
#include <sstream>

template<typename E>
inline string QFMutableArray<E>::str()
{	
	if (len == 0) {
		return "[]";
	}
    // 拼接元素
	ostringstream oss;
	oss << "[";

	for (int i = 0; i < len - 2; i++) {
		oss << array[i] << ", ";
	}

	oss << array[len - 1] << "]";

	return string();
}
```

### 实现添加元素到末尾

可以创建一个新的数组，将原来的数组元素都添加到这个新数组里面去，然后最后一位添加新元素，扩大长度，删除原数组，修改原数组指向

```c++
template<typename E>
inline void QFMutableArray<E>::add(E ele)
{
	// 创建一个新数组，长度为之前数组的个数+1，将原来数组元素都拷贝到新数组，将新元素放在数组末尾
	E* newArray = new E[len + 1];
	// 元素拷贝
	for (int i = 0; i < len; i++) {
		newArray[i] = array[i];
	}
	// 新数组尾部插入元素
	newArray[len ] = ele;
	// 长度自增
	len++;
	// 删除原数组
	delete array;
	// 修改指针指向
	array = newArray;
}
```



 ### 添加元素到指定位置

主要步骤和上面类似，但是区别在于，当遇到对应的index下标的时候，此时新的数组就不需要添加旧数组里面的元素，跳过当前循环，等所有的元素都遍历完成后，在将指定元素插入到对应位置。

```c++
template<typename E>
inline void QFMutableArray<E>::add(int index, E ele)
{
	if (index > len || index < 0) {
		cout << "下标位置不合理" << endl;
		return;
	}

	//新建数组
	E* newArray = new int[len+1];

	// 拷贝元素
	for (int j = 0 ,i = 0; j < len+1; j++) {
		// 不拷贝
		if (j == index) {
			continue;
		}
		newArray[j] = array[i++];
	}

	// 设置元素
	newArray[index] = ele;

	// 扩大长度
	len++;
	// 删除原数组
	delete array;
	// 重新指向新数组
	array = newArray;
}
```

### 删除指定下标

依然是出现一个位数不一致的情况，处理方式和上面的一样，需要跳过当前这一位

![image-20240228171704490](http://cdn.flycode.icu/codeCenterImg/image-20240228171704490.png)

```c++
template<typename E>
inline E QFMutableArray<E>::remove(int index)
{
	if (index >= len || index < 0) {
		cout << "下标不合理" << endl;
		return -1;
	}
	// 创建新数组，长度减1
	E* newArray = new E[len - 1];
	// 记录目标值
	E temp = array[index];
	// 遍历数组
	for (int i = 0,j = 0; i < len; i++) {
		// 如果是指定的下标，就跳过循环
		if (i == index) {
			continue;
		}
		newArray[j++] = array[i];
	}

	// 长度减少
	len--;
	// 删除原数组
	delete array;
	// 指针指向新数组
	array = newArray;

	return temp;
}
```

### 寻找指定元素

```c++
template<typename E>
inline int QFMutableArray<E>::index(E ele)
{
	for (int i = 0; i < len; i++) {
		if (ele == array[i]) {
			return i;
		}
	}
	return -1;
}
```

### 删除指定元素

目前设定里面不存在对应的重复元素，需要先找到下标，然后利用之前写好的删除下标元素函数

```c++

template<typename E>
inline bool QFMutableArray<E>::removeElement(E ele)
{
	// 找到下标
	E idx = index(ele);
	// 判断是否存在
	if (idx == -1) {
		return false;
	}
	// 移除元素
	remove(idx);
	return true;
}
```

### 清空数组

只需要删除

```c++
template<typename E>
inline void QFMutableArray<E>::clear()
{
	// 清除原数组
	delete array;
	// 重置数组
	array = new E[0];
	len = 0;
}
```

