# 面向对象
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://flycode.icu)



## 类的设计和对象创建

### 类的设计

使用关键字class描述一个类

类是有若干个相同的特征和功能对象的集合，类里面书写对象共有的特征和行为。有属性和函数组成。

默认创建的class是私有权限，也就是private

访问权限：

private：私有权限，当前类里面才能访问

protected: 保护权限，类外不能访问，当前类和子类访问

public: 公开权限，任意地方访问

```c++

class Person {
public:
	string name;
	int age;
	double score;
	int gender;

	void eat() {
		cout << "吃饭" << endl;
	}

	void sleep() {
		cout << "睡觉" << endl;
	}
};

```

### 类的创建

两种方式

```c++
// 在栈里面开辟
Person person1 = Person();
// 在堆上开辟
Person* person = new Person();
```

![image-20240223152401423](http://cdn.flycode.icu/codeCenterImg/image-20240223152401423.png)

类里面有属性，类的占用空间的大小是所有属性占用的空间和

类里面没有属性，类的占用的空间大小是1



### 成员访问

没有使用new

```c++
cout << person1.age << endl;
cout << person1.name << endl;
cout << person1.gender << endl;
cout << person1.score << endl;
person1.eat();
person1.sleep();
```

使用new

```c++
person->age = 90;
person->name = "test2";
person->gender = 2;
person->score = 100;
cout << person->age << endl;
cout << person->name << endl;
cout << person->gender << endl;
cout << person->score << endl;
person->eat();
person->sleep();
```

![image-20240223154255951](http://cdn.flycode.icu/codeCenterImg/image-20240223154255951.png)

因为是一个指针，所有我们也可以通过指针的方式来访问，比如`(*person).age`



### 引入另一个类

```c++
class Dog {
public:
	string name;
	int age;
};

class Person
{
public:
	string name;
	int age;
	Dog dog1;

	Dog* dog2;
};
```

两个引用Dog的区别在于

`Dog dog1 = Dog()`

`Dog* dog2 = NULL`

所以我们进行访问对应的属性的时候，如果这个属性类是使用指针来创建的话，因为这个指针一开始是空的，所以直接访问里面的元素，会报空指针异常，需要注意。

```c++
	Person p1 = Person();
	p1.age = 100;
	p1.name = "test";
	p1.dog1.age = 2;
	p1.dog1.name = "test dog";
	cout << p1.age << endl;
	cout << p1.name << endl;
	cout << p1.dog1.age << endl;
	cout << p1.dog1.name << endl;


	p1.dog2 = new Dog();
```

### 案例一：老师-学生

xx老师让xx学生上台自我介绍

老师类: 

- 属性：姓名
- 功能：让学生自我介绍

学生类: 

- 属性 姓名，年龄，性别，成绩
- 功能：自我介绍

```c++
#include<iostream>
using namespace std;


class Student {
public:
	string name;
	int age;
	int sex;
	double score;

	void show() {
		cout << name<<": 开始自我介绍" <<" 年龄："<<age<<"  性别："<<sex<<" 分数："<<score << endl;
	}
};

class Teacher {
public:
	string name;
	
	void call(Student stu) {
		cout << "让学生:"<<stu.name<<"自我介绍" << endl;
		stu.show();
	}
};

int main() {
	// 学生初始化
	Student stu1 = Student();
	stu1.name = "张三";
	stu1.age = 18;
	stu1.sex = 1;
	stu1.score = 80;

	// 老师初始化
	Teacher te = Teacher();
	te.name = "李四";

	// 核心业务
	te.call(stu1);

}
```

### 案例二：判断圆是否包含一个点

圆：

- 属性：圆心，半径
- 功能：判断圆是否包含一个点

点：

- 属性：x，y



```c++
#include<iostream>
using namespace std;

class Point {
public:
	double x;
	double y;
};


class Circle {
public:
	double r;
	Point center;

	bool contains(Point point) {
		// 计算两点距离的平方
		double dis = (center.x - point.x) * (center.x - point.x) + (center.y - point.y) * (center.y - point.y);
		// 计算平方和和半径的关系
		return dis >= r * r;
	}
};

int main() {
	// 点
	Point point = Point();
	point.x = 2;
	point.y = 4;

	// 圆
	Circle circle = Circle();
	circle.r=1;
	circle.center.x = 2;
	circle.center.y = 4;

	cout << (circle.contains(point) == 1 ? "true" : "false") << endl;;
}
```



## 类外和其他文件实现类函数

将函数移到外面创建

```c++
class Person {
public:
	void sleep();
};

void Person::sleep(){
	cout << "sleep" << endl;
}
```

可以在新建里面选择对应的类，会创建对应的头文件和cpp文件实现

![image-20240223163110354](http://cdn.flycode.icu/codeCenterImg/image-20240223163110354.png)



## 静态

使用关键字static



### 静态常量

const static int

### 静态函数

static void show

### 静态属性

静态的属性存放在全局区，程序编译的时候已经完成了空间的开辟与初始化的赋值操作。

静态属性的空间开辟早于对象的创建，静态属性不属于对象，被所有的对象共享。



### 访问方式

1. 通过对象访问
2. 通过类访问（推荐）

```c++
#include<iostream>
using namespace std;

class MyNumber {
public:
	// 静态成员
	static int a;
	// 静态常量,数据类型是整型，允许在定义的时候进行初始化赋值，其他类型不允许
	const static int PI = 3;

	const static double PI2;

	// 静态函数
	static void show() {
		cout << "静态函数的调用" << endl;
	}
};

int MyNumber::a = 10;
const double MyNumber::PI2 = 3.1;


int main() {
	// 对象进行访问
	MyNumber num1;
	MyNumber num2;

	cout << num1.a << endl;
	cout << num2.a << endl;

	// 修改了一个值会修改所有的值
	num1.a = 100;
	cout << num1.a << endl;
	cout << num2.a << endl;



	// 类访问
	MyNumber::a = 200;
	cout << num1.a << endl;
	cout << num2.a << endl;


	// 调用函数
	MyNumber::show();
}
```



## 构造函数

### 构造函数分类

- 参数：有参和无参构造
- 类型：普通构造，拷贝构造

### 构造函数的定义

对对象属性初始化的赋值操作

```c++
class Per {
public:
	Per() {
		cout << "无参构造" << endl;
	}

	Per(int age) {
		cout << "有参构造" << endl;
	}

};
```

### 构造函数的调用

```c++
	// 1.显示调用
	Per per1 = Per();               // Per per1; 缩写不能加上（）
	Per per2 = Per(10);				// Per per2(10)
	Per per3 = Per(10, 10);			// Per per3(10,10)

	//2. 隐式调用
	Per per4 = {};
	Per per5 = { 10 };
	Per per6 = { 10,10 };
```

### explict关键字

放在构造函数前面**修饰构造函数，无法使用隐式调用**

```c++
	explicit Per(int age) {
		cout << "{int}有参构造" << endl;
	}
```

### 注意事项

如果我们创建了一个空的对象。系统会默认帮我们创建一个空的构造函数。但是如果我们重写了新的构造函数，那么原本的空参就不会存在了，此时如果还是空参调用，就会报错。

所以一般情况下，我们会主动再写一个空参构造。



### 构造函数初始化

```c++
#include<iostream>
using namespace std;


class Pers {
public:
	string name;
	int age;
	string sex;
	int score;

	Pers() {
		name = "";
		age = 0;
		sex = "";
		score = 0;
	}

	//Pers(string n,int a,string g,int s) {
	//	name = n;
	//	age = a;
	//	sex = g;
	//	score = s;
	//}

	Pers(string n, int a, string g, int s) :name(n), age(a), sex(g), score(s) {
	}

	void show() {
		cout << "name=" << name << " age=" << age << " sex=" << sex << " score=" << score << endl;
	}
};

int main() {
	Pers per = Pers("test",12,"nan",88);
	per.show();
	return 0;
}
```

### 拷贝构造函数

根据一个对象拷贝出另一个对象，这两个对象的值相等，但是**地址不相同**

可以看作一个常量引用，如果不创建，就会使用默认的拷贝构造函数

```c++
	Pers(const Pers& per) {
		cout << "拷贝构造函数调用了" << endl;
		name = per.name;
		age = per.age;
		sex = per.sex;
		score = per.score;
	}
```

```c++
Pers per = Pers("test",12,"nan",88);
Pers per2 = per;
```



## 析构函数

对象生命周期的终点，对象被销毁之前调用

资源释放，堆内存释放

使用~

```c++
#include<iostream>
using namespace std;

class Perso {
public:
	int a;
	~Perso() {
		cout << "析构函数被调用了" << endl;
	}
};


void test() {
	Perso person;  // 栈里面，test调用结束后才会释放
}


int main() {
	test();

	//Perso* person = new Perso();
    // 释放堆空间
	//delete person;

	system("pause");
	return 0;
}
```

因为函数里面的对象是在栈里面，调用方法结束后会自动化销毁

![image-20240223180125420](http://cdn.flycode.icu/codeCenterImg/image-20240223180125420.png)

如果使用的是指针创建，`	Perso* person = new Perso();`这个是存放在堆里面，不会调用析构函数。

![image-20240223180221186](http://cdn.flycode.icu/codeCenterImg/image-20240223180221186.png)

所以必须要使用`delete`来删除占用

## 浅拷贝和深拷贝

浅拷贝：在拷贝函数中，直接完成属性的值拷贝

深拷贝：在拷贝函数中，创建新的空间，属性中的指针指向一个新的空间

### 浅拷贝

```c++
#include<iostream>
using namespace std;


class Cat {
public:
	string name;
	int age;
};


class Person {
public :
	int age;
	Cat* pet;

	Person() {
		age = 0;
		pet = new Cat();
	}

	// 拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		// 默认是浅拷贝
		pet = p.pet;
		// 深拷贝
		//pet = new Cat();
		//pet->name = p.pet->name;
		//pet->age = p.pet->age;
	} 

	// 析构函数
	~Person()
	{	
		cout << "开始调用析构函数" << endl;
		if (pet != nullptr) {
			delete pet;
			pet = nullptr;
		}

	}
};

int main() {
	Person test1;

	Person test2 = test1;

	system("pause");
	return 0;
}
```

![image-20240224160804209](http://cdn.flycode.icu/codeCenterImg/image-20240224160804209.png)

上图我们可以看到两个对象都是使用的同一个cat空间，但是一旦test2执行完成了，会执行析构函数，变成下图

![image-20240224161018696](http://cdn.flycode.icu/codeCenterImg/image-20240224161018696.png)

所以会导致第一个对象里面遗留了一个野指针。

### 深拷贝

```c++
pet = new Cat();
pet->name = p.pet->name;
pet->age = p.pet->age;
```

这样就会创建两个pet在堆里面，析构函数执行的时候就不会出现野指针的情况

![image-20240224161305380](http://cdn.flycode.icu/codeCenterImg/image-20240224161305380.png)



## this指针

### 使用

**指向当前对象的指针，谁调用这个函数，这个this就指向谁**

```c++
#include<iostream>
using namespace std;

class Person {
public:
	int age;
	Person() {
		age = 0;
	}
	Person(int age) {
		age = age;
	}
	//Person(int age):age(age){}
};

int main() {
	Person xiaoming(10);
	cout << xiaoming.age << endl;

	Person xiaobai(20);
	cout << xiaobai.age << endl;

	return 0;
}
```

以上代码运行的时候会存在问题，一个是代码提示，另一个是执行结果的原因

![image-20240224162350810](http://cdn.flycode.icu/codeCenterImg/image-20240224162350810.png)

因为这两个变量名重复了，所以无法分辨是哪个变量的赋值，三种解决方案

- 参数名或者变量名不一样，要有区分
- 使用this指针`this->age = age;`
- 构造函数初始化，Person(int age):age(age){}



### this不能省略情况

1. 局部变量和属性名字相同的时候，需要使用显示的this，一般情况下this可以省略



### 返回当前对象的函数

在函数上面可以使用引用，这样就能避免在内存上创建两个当前的资源，然后返回的时候可以使用*this指针指向当前对象

```c++
#include<iostream>
using namespace std;

class MyNumber {
private:
	int n;

public:
	MyNumber() :n(0) {};
	MyNumber(int n) :n(n) {};


	// 返回当前的对象，可以使用引用，避免值拷贝
	MyNumber& add(int n) {
		this->n += n;
		return *this;
	}


	MyNumber& mins(int n) {
		this->n -= n;
		return *this;
	}
};



int main() {
	MyNumber myNumber = { 10 };
	MyNumber res = myNumber.add(10).add(20).mins(10);
}
```

而且这样还能使用流式或链式调用。



### 空指针

可以使用空指针调用成员函数，需要这个函数里面不出现this访问。需要避免空指针，野指针。

```c++
#include<iostream>
using namespace std;

class MyNumber {
public:
	int age;

	void func1() {
		cout << this->age << endl;
	}


	void func2() {
		if (this == NULL) {
			cout << "空指针存在" << endl;
            return;
		}
		cout << "不是空指针" << endl;
	}
};

int main() {
	MyNumber* m1 = nullptr;
	m1->func1();
	//m1->func2();
}
```



运行方法1，出现空指针

![image-20240224165236543](http://cdn.flycode.icu/codeCenterImg/image-20240224165236543.png)

运行方法2

![image-20240224165347021](http://cdn.flycode.icu/codeCenterImg/image-20240224165347021.png)



## 常函数

- 使用const修饰
- 常函数里面不允许修改属性值
- 常函数不允许调用普通函数，只能调用其他的常函数



```c++
#include<iostream>
using namespace std;

class Person {
public:
	string name;
	int age;
	Person() :name(""), age(0) {};
	Person(string name, int age) :name(name), age(age) {};

	void changePerson(string name, int age) {
		this->name = name;
		this->age = age;
	}
};


int main() {

}
```

给changePerson加上const，发现无法赋值，报错。

![image-20240224171525240](http://cdn.flycode.icu/codeCenterImg/image-20240224171525240.png)



## 常对象

- 创建对象的时候使用const修饰对象
- 可以读取任意属性的值，但是不允许修改
- 常对象，只能调用常函数，不能调用普通函数

![image-20240224171645373](http://cdn.flycode.icu/codeCenterImg/image-20240224171645373.png)

发现无法进行赋值，但是可以读取里面的值，而且能够调用常函数





## mutable

修饰属性，表示可变

- 被修饰的属性可以在常函数中修改，也可在常对象里面修改

```c++
class Person {
public:
	string name;
	mutable int age;
	Person() :name(""), age(0) {};
	Person(string name, int age) :name(name), age(age) {};

	void changePerson(string name, int age) const{
		this->age = age;
	}
};


int main() {

	const Person p = { "test",12 };
	// p.age = 20;
	p.age = 20;
	p.changePerson("test2", 22);
}
```

## 友元

### 友元是什么？

类的主要特点是可以隐藏自己内部的数据，外界无法访问，有的时候需要在外部访问类的私有成员，需要友元函数，也就是特权函数

### 全局函数做友元

定义一个房子，有一个私有属性和公有属性

```c++
class MyRoom {
public:
	string livingRoom = "客厅";
private:
	string bedRoom = "卧室";
};
```

使用函数来访问这个私有属性，很显然是无法访问的，

![image-20240224172739679](http://cdn.flycode.icu/codeCenterImg/image-20240224172739679.png)

我们可以将当前函数设置为友元函数，然后可以正常访问

![image-20240224172904012](http://cdn.flycode.icu/codeCenterImg/image-20240224172904012.png)

### 成员函数做友元

实现较为复杂。

```c++
#include<iostream>
using namespace std;

// 1.必须要先声明
class MyRoom;

// 2.必须要在MyRoom上面
class GoodFriend {
public:
	MyRoom* myRoom;

	//3. 不能在此处实现
	void visit();
};


class MyRoom {
	// 4.成员函数做友元
	friend void GoodFriend::visit();
public:
	string livingRoom = "客厅";
private:
	string bedRoom = "卧室";
};

//5.实现成员函数
void GoodFriend::visit() {
	cout << myRoom->bedRoom << endl;
	cout << myRoom->livingRoom << endl;
}

int main() {
	GoodFriend gd;
	MyRoom mm ;
	gd.myRoom = &mm;
	gd.visit();
}
```

### 类做友元

类里面的所有成员函数都能访问私有属性

```c++
class Room {
	friend class Friend;
public:
	string liveingRoom = "客厅";
private:
	string bedRoom = "卧室";
};

class Friend {
	Room* room;
	void visit() {
		room->liveingRoom;
		room->bedRoom;
	}
};
```





## 重载运算符

对已有的运算符进行重新定义，适应不同的数据结构

### 可重载运算符

![image-20240224175318219](http://cdn.flycode.icu/codeCenterImg/image-20240224175318219.png)



### +运算重载

必须要使用`operator`+对应的重载运算符号

```c++
class Point {
public:
	int x;
	int y;

	Point() :x(0), y(0) {};
	Point(int x, int y) : x(x), y(y) {};

};


Point operator+(Point p1,Point p2) {
	return Point(p1.x + p2.x, p1.y + p2.y);
}

int main() {
	Point p1 = { 1,2 };
	Point p2 = { 2,2 };

	Point p3 = p1 + p2;

	cout << "x=" << p3.x << " y=" << p3.y << endl;
}
```

但是以上方式比较耗费空间，因为每次都是值复制，所有我们可以使用引用

```c++
Point operator+(const Point& p1,const Point& p2) {
	return Point(p1.x + p2.x, p1.y + p2.y);
}
```

可以在类里面定义，但是只能有一个函数

```c++
class Point {
public:
	int x;
	int y;

	Point() :x(0), y(0) {};
	Point(int x, int y) : x(x), y(y) {};

	// 里面只能有一个参数
	Point operator+(const Point& p1) {
		return { this->x - p1.x,this->y - p1.y };
	}

};
```

### ++运算重载

#### 先运算，在取值

```c++
Point operator++( Point& p) {
	p.x++;
	p.y++;
	return p;
}
```

#### 先取值，后运算

```c++
Point operator++(Point& p,int) {
	Point point = p;
	p.x++;
	p.y++;
	return point;
}
```



#### --运算重载

类里面

#### 先运算后取值

```c++
	Point operator--() {
		x--;
		y--;
		return *this;
	}
```

#### 先取值后运算

```c++
	Point operator--(int) {
		Point temp = *this;
		x--;
		y--;
		return temp;
	}
```

