# 指针和内存
> 本文作者：程序员飞云
>
> 本站地址：[https://www.flycode.icu](https://flycode.icu)

## 分区作用

### 代码区

存储程序编译后的函数体二进制代码，操作系统进行管理。

函数在程序编译之后，存储于代码区，调用函数的时候，会压到栈里面去执行其中的代码



### 全局区

变量在程序编译阶段已经分配好内存空间并初始化，这块内存空间在程序的整个运行期间都存在，主要存放静态变量、全局变量和常量

![image-20240220164537472](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240220164537472.png)

### 栈区

由系统进行内存管理，主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放，不需要用户管理。

### 堆区

由程序员进行分配和释放，若程序员不能释放，程序结束时由操作系统进行回收

### 内存中的数据残留

删除硬盘上面的数据只是释放掉自己对于某一块空间的使用权，内存也是如此。

![image-20240220170209394](https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com//codeCenterImg/image-20240220170209394.png)



## 指针



### 指针的使用

```c++
int main() {
	int a = 10;
	int* p = &a;

	cout <<"内存地址：" << p << endl;

	// 地址访问
	cout << "*p的值：" << *p << endl;
	// 通过指针修改值
	*p = 200;
	cout <<"*p的值：" << *p << endl;
}
```

### 空指针和野指针

空指针：没有存储任何的内存地址的指针变量，一般使用NULL或者nullptr

野指针：里面存储一个内存地址，但是这个地址指向的空间已经不存在了。

### 常量指针和指针常量



常量指针：指向常量的指针  const int * a

- 指向的空间值是不允许修改的
- 指针的指向可以修改

```c++
	int a = 10;
	// 常量指针
	const int* p = nullptr;
	p = &a;

	// *p = 200; 无法通过指针修改值

	// 但是可以修改指针的指向
	int b = 20;
	p = &b;
```

指针常量：int *const a

- 可以修改指向空间的值
- 但是无法修改指针的转向

```c++
	int a = 10;
	int b = 20;

	int* const p = &a;
	//*p = &b; //    无法修改指向
	*p = 200;  // 但是可以修改值
```



## 函数中使用指针

```c++
void change(int num) {
	num = 100;
}

int main() {
	int n = 10;
    change(n);
	cout << n << endl;
}
```

以上题为例，如果我们希望最后输出的是100，而不是10，应该如何处理？

> 函数里面参数值可以看作是一个复制，将输入的值复制给参数，然后再使用。所以我们如果希望不使用复制，那就意味着内存地址是不可以修改的，而是只能修改对应的内存值，我们可以使用指针常量。此处我们直接传入地址给函数，然后让函数指向这个地址，让这个函数修改值就可以。

```c++
void change(int* num) {
	*num = 100;
}

int main() {
	int n = 10;
	change(&n);
	cout << n << endl;
}
```

## 引用

变量名是一段连续内存空间的别名，是一个标号，程序中可以通过变量来申请并命名空间，通过变量的名字来使用变量空间

引用注意事项：

- &这里不是用于计算
- 类型标志符和目标类型必须要一致
- 声明引用变量的时候必须进行初始化
- 引用初始化后，地址不能改变
- 不能由NULL 
- 看作是一个别名

```c++
int a = 10;
// 引用
int &b = a;

// 两个地址一样
cout << &a << endl;
cout << &b << endl;
```



### 函数中使用引用



```c++
void swap(int num1, int num2) {
	int temp = num1;
	num1 = num2;
	num2 = temp;
}

int main() {
	int num1 = 10;
	int num2 = 33;

	swap(num1, num2);
	cout << "num1=" << num1 << "\tnum2=" << num2 << endl;
}
```

运行以上代码后，我们可以发现最后的值还是是num1=10，num2=33，但是很显然不是我们想要的

```c++
void swap(int& num1, int& num2) {
	int temp = num1;
	num1 = num2;
	num2 = temp;
}
```

### 引用的本质

是指针常量 

 int *const a = &b <====>  int& a = b



### 常量引用

const int&  a = 10; 一般在函数里面，不想形参修改实参的值
